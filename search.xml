<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis缓存问题</title>
      <link href="/2020/08/02/redis-huan-cun-wen-ti/"/>
      <url>/2020/08/02/redis-huan-cun-wen-ti/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Redis 作为缓存应用在各种大型项目中，但在实际开发中不得不考虑许多常见问题</p></blockquote><h2 id="一-缓存穿透"><a href="#一-缓存穿透" class="headerlink" title="一 缓存穿透"></a>一 缓存穿透</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>如果查询一个系统根本不存在的数据，缓存层和数据库均不会命中，从而导致每次请求都要到持久层数据库查询，从而失去了缓存的意义，同时也给攻击者留下后门，增大系统风险。</p><p>这可能是业务代码或数据自身问题导致，也不能排除恶意攻击。</p><h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul><li><strong>缓存空对象</strong></li></ul><p>当持久层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源。</p><p>适用于数据频繁变换且实时性高的场景，代码上实现简单，需要额外开销，且存在数据不一致的问题。</p><ul><li><strong>接口层校验</strong></li></ul><p>通常使用<a href="https://www.jianshu.com/p/2104d11ee0a2" target="_blank" rel="noopener"><strong>布隆过滤器（Bloom Filter）</strong></a>实现，适用于数据固定的场景，其优势是节约空间，但维护复杂。</p><h2 id="二-缓存击穿"><a href="#二-缓存击穿" class="headerlink" title="二 缓存击穿"></a>二 缓存击穿</h2><h3 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>热点数据的并发量很大，缓存失效后会导致大量请求直接指向持久层，造成数据的压力瞬间增大。</p><h3 id="2-解决方案-1"><a href="#2-解决方案-1" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul><li><strong>热点数据永不过期</strong></li></ul><p>但无法保证数据的一致性，且增大维护成本。</p><ul><li><strong>互斥锁</strong></li></ul><p>当缓存未命中数据，则由第一个请求进入的线程获取到互斥锁，从数据库中获取数据，其余线程等待第一个线程释放锁后再从缓存中获取数据。</p><p><strong>穿透 VS 击穿</strong></p><ul><li>缓存穿透：缓存层和持久层均无数据</li><li>缓存击穿：缓存层无数据但持久层有数据</li></ul><h2 id="三-缓存雪崩"><a href="#三-缓存雪崩" class="headerlink" title="三 缓存雪崩"></a>三 缓存雪崩</h2><h3 id="1-问题描述-2"><a href="#1-问题描述-2" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>大批量数据同时到期或者缓存层宕机，导致大批量流量直接打到持久层，增大数据库的压力。</p><h3 id="2-解决方案-2"><a href="#2-解决方案-2" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul><li><strong>缓存时间随机或热点数据不过期</strong></li><li><strong>缓存层分布式部署，提高可用性</strong></li><li><strong>依赖隔离组件为后端存储限流并降级</strong></li></ul><p><strong>击穿 VS 雪崩</strong></p><ul><li>缓存击穿：针对同一条热点数据</li><li>缓存雪崩：大批量同时到期数据</li></ul><h2 id="四-缓存无底洞"><a href="#四-缓存无底洞" class="headerlink" title="四 缓存无底洞"></a>四 缓存无底洞</h2><h3 id="1-问题描述-3"><a href="#1-问题描述-3" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>随着节点增加，一次批量操作可能会设计多次网络请求一访问多个节点，导致耗时不降反增。</p><h3 id="2-解决方案-3"><a href="#2-解决方案-3" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h3><ul><li><strong>串行 mget</strong></li></ul><p>将 mget 操作（n 个 key）拆分为逐次执行 N 次 get 操作。</p><ul><li><strong>串行 IO</strong></li></ul><p>对批量操作中的 key 值按节点分类归档，然后逐次进行 mget 操作。</p><ul><li><strong>并行 IO</strong></li></ul><p>将串行 IO 方案中的逐次操作改为多线程并发操作。</p><ul><li><strong>hash-tag</strong></li></ul><p>可以将多个 key 值强制分配到同一个节点，但也会导致数据倾斜。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《Redis开发与运维》 付磊 张益军</li><li><a href="https://blog.csdn.net/kongtiao5/article/details/82771694" target="_blank" rel="noopener">缓存穿透、缓存击穿、缓存雪崩区别和解决方案</a></li><li><a href="https://www.iteye.com/blog/carlosfu-2263813" target="_blank" rel="noopener">缓存系列文章–7.无底洞问题(multiget hole)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象的原则</title>
      <link href="/2020/07/26/mian-xiang-dui-xiang-de-yuan-ze/"/>
      <url>/2020/07/26/mian-xiang-dui-xiang-de-yuan-ze/</url>
      
        <content type="html"><![CDATA[<p>对于面向对象语言而言，有“六原则，一法则”去遵循：</p><h2 id="六原则"><a href="#六原则" class="headerlink" title="六原则"></a>六原则</h2><ul><li>单一原则：一个类只应该做它该做的事情，做到高聚合，低耦合</li><li>开闭原则：开放拓展，关闭修改。既尽量从原有系统派生出新类，而避免直接对原系统的修改</li><li>依赖倒置原则：面向接口编程</li><li>里氏替换原则：任何时候都可以使用子类型替换父类型，否则就是不合理</li><li>接口隔离原则：接口小而专，不能大而全</li><li>聚合复用原则：优先使用聚合关系复用代码，既使用 Has-a 而非 Is-a</li></ul><h2 id="一法则"><a href="#一法则" class="headerlink" title="一法则"></a>一法则</h2><p><strong>迪米特法则</strong>：又名最少知识原则，是指一个对象应对其它对象有最少的了解，既低耦合。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 入门</title>
      <link href="/2020/07/18/markdown-ru-men/"/>
      <url>/2020/07/18/markdown-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="关于Markdown"><a href="#关于Markdown" class="headerlink" title="关于Markdown"></a>关于Markdown</h3><blockquote><p>Markdown是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文本</p></blockquote><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>因为写博文需经常用到Markdown语法，于是产生了对Markdown语法进行系统整理的想法。<br>​    </p><h3 id="Markdown的优势"><a href="#Markdown的优势" class="headerlink" title="Markdown的优势"></a>Markdown的优势</h3><ul><li>简单标记符完成排版，所写即所见，让你专注于文字而不是排版</li><li>纯文本，所以兼容性极强，可以用所有文本编辑器打开</li><li>格式转换方便，Markdown文本可以轻松转换为 html、pdf等</li><li>Markdown 的标记语法有极好的可读性</li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a><strong>1. 斜体和粗体</strong></h4><p>代码：</p><pre><code>*斜体*或_斜体_**粗体*****加粗斜体***~~删除线~~</code></pre><p>显示效果：</p><ul><li><em>斜体</em>或<em>斜体</em></li><li><strong>粗体</strong></li><li><strong><em>加粗斜体</em></strong></li><li><del>删除线</del></li></ul><h4 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a><strong>2. 分级标题</strong></h4><p>第一种写法：</p><pre><code>这是一个一级标题============================这是一个二级标题--------------------------------------------------</code></pre><p>第二种写法：</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h4 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3. 超链接"></a><strong>3. 超链接</strong></h4><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式，行内式一般使用较多。</p><h4 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1. 行内式"></a>3.1. 行内式</h4><p>语法说明：</p><pre><code>[]里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。[链接文字](链接地址 “链接标题”)’这样的形式。链接地址与链接标题前有一个空格。</code></pre><p>代码：</p><pre><code>欢迎来到[CSDN](http://csdn.net)欢迎来到[CSDN](http://csdn.net &quot;CSDN&quot;)这里写代码片</code></pre><p>显示效果：</p><ul><li>欢迎来到<a href="http://csdn.net" target="_blank" rel="noopener">CSDN</a></li><li>欢迎来到<a href="http://csdn.net" target="_blank" rel="noopener" title="CSDN">CSDN</a></li></ul><h4 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2. 参考式"></a>3.2. 参考式</h4><blockquote><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p></blockquote><p>语法说明： </p><pre><code>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。如果链接文字本身可以做为链接标记，你也可以写成[链接文字][] [链接文字]：链接地址的形式，见代码的最后一行。</code></pre><p>代码：</p><pre><code>我经常去的几个网站[Baidu][1]、[CSDN][2]以及[自己的博客][3][Leanote 笔记][2]是一个不错的[网站][]。[1]:http://www.baidu.com &quot;Google&quot;[2]:http://www.csdn.net&quot;Leanote&quot;[3]:http://http://blog.csdn.net/adminpd&quot;梵居闹市&quot;[网站]:http://http://blog.csdn.net/adminpd</code></pre><p>显示效果：</p><ul><li>我经常去的几个网站<a href="http://www.baidu.com" target="_blank" rel="noopener" title="Google">Baidu</a>、<a href="http://www.csdn.net" target="_blank" rel="noopener"Leanote"">CSDN</a>以及<a href="http://http://blog.csdn.net/adminpd" target="_blank" rel="noopener"梵居闹市"">自己的博客</a></li><li><a href="http://www.csdn.net" target="_blank" rel="noopener"Leanote"">Leanote 笔记</a>是一个不错的<a href="http://http://blog.csdn.net/adminpd" target="_blank" rel="noopener">网站</a>。</li></ul><h4 id="3-3-自动链接"><a href="#3-3-自动链接" class="headerlink" title="3.3. 自动链接"></a>3.3. 自动链接</h4><p>语法说明： </p><pre><code>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</code></pre><p>代码：</p><pre><code>&lt;http://example.com/&gt;&lt;address@example.com&gt;</code></pre><p>显示效果：</p><ul><li><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a></li><li><a href="mailto:&#97;&#100;&#100;&#x72;&#x65;&#x73;&#115;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#109;">&#97;&#100;&#100;&#x72;&#x65;&#x73;&#115;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#109;</a></li></ul><h4 id="4-锚点"><a href="#4-锚点" class="headerlink" title="4. 锚点"></a><strong>4. 锚点</strong></h4><blockquote><p>网页中，锚点其实就是页内超链接，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。还有下一节的注脚。这些根本上都是用锚点来实现的。</p></blockquote><p>注意： </p><pre><code>1. Markdown Extra 只支持在标题后插入锚点，其它地方无效。 2. Leanote 编辑器右侧显示效果区域暂时不支持锚点跳转，所以点来点去发现没有跳转不必惊慌，但是你发布成笔记或博文后是支持跳转的。</code></pre><p>语法描述： </p><pre><code>在你准备跳转到的指定标题后插入锚点{#标记}，然后在文档的其它地方写上连接到锚点的链接。</code></pre><p>代码：</p><pre><code>## 0. 目录{#index}跳转到[目录](#index)</code></pre><p>显示效果：</p><ul><li>跳转到<a href="#index">目录</a></li></ul><h4 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a><strong>5. 列表</strong></h4><h4 id="5-1-无序列表"><a href="#5-1-无序列表" class="headerlink" title="5.1. 无序列表"></a>5.1. 无序列表</h4><blockquote><p>使用 *，+，- 表示无序列表。</p></blockquote><p>代码：</p><pre><code>- 无序列表项 一- 无序列表项 二- 无序列表项 三</code></pre><p>显示效果：</p><ul><li><p>无序列表项 一</p></li><li><p>无序列表项 二</p></li><li><p>无序列表项 三</p></li></ul><h4 id="5-2-有序列表"><a href="#5-2-有序列表" class="headerlink" title="5.2. 有序列表"></a>5.2. 有序列表</h4><blockquote><p>有序列表则使用数字接着一个英文句点。</p></blockquote><p>代码：</p><pre><code>1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三</code></pre><p>显示效果：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h4 id="5-3-定义型列表"><a href="#5-3-定义型列表" class="headerlink" title="5.3. 定义型列表"></a>5.3. 定义型列表</h4><p>语法说明：</p><pre><code>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)</code></pre><p>代码：</p><pre><code>Markdown:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）代码块 2:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）        代码块（左侧有八个不可见的空格）</code></pre><p>显示效果：</p><dl><dt>Markdown<br>:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）<br>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）<br>        代码块（左侧有八个不可见的空格）</dd></dl><p>代码块（左侧有八个不可见的空格）</p><h4 id="5-4-列表缩进"><a href="#5-4-列表缩进" class="headerlink" title="5.4. 列表缩进"></a>5.4. 列表缩进</h4><p>语法说明：</p><blockquote><p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p></blockquote><p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好（显示效果与代码一致）：</p><pre><code>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>但是如果你懒，那也行： </p><p>代码：</p><pre><code>*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！ *   那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ 悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>显示效果：</p><p>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！<br>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！<br>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</p><h4 id="5-5-包含段落的列表"><a href="#5-5-包含段落的列表" class="headerlink" title="5.5. 包含段落的列表"></a>5.5. 包含段落的列表</h4><p>语法说明：</p><blockquote><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符（显示效果与代码一致）：</p></blockquote><pre><code>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。 那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p><p>代码：</p><pre><code>*   轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。 软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！*     那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。 寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。 但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ *    悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</code></pre><p>显示效果：</p><ul><li>轻轻的我走了， 正如我轻轻的来； 我轻轻的招手， 作别西天的云彩。<br>那河畔的金柳， 是夕阳中的新娘； 波光里的艳影， 在我的心头荡漾。<br>软泥上的青荇， 油油的在水底招摇； 在康河的柔波里， 我甘心做一条水草！</li><li>那榆荫下的一潭， 不是清泉， 是天上虹； 揉碎在浮藻间， 沉淀着彩虹似的梦。<br>寻梦？撑一支长篙， 向青草更青处漫溯； 满载一船星辉， 在星辉斑斓里放歌。<br>但我不能放歌， 悄悄是别离的笙箫； 夏虫也为我沉默， 沉默是今晚的康桥！ </li><li>悄悄的我走了， 正如我悄悄的来； 我挥一挥衣袖， 不带走一片云彩。</li></ul><h4 id="5-6-包含引用的列表"><a href="#5-6-包含引用的列表" class="headerlink" title="5.6. 包含引用的列表"></a>5.6. 包含引用的列表</h4><p>语法说明：</p><pre><code>如果要在列表项目内放进引用，那 &gt; 就需要缩进：</code></pre><p>代码：</p><pre><code>*   阅读的方法:    &gt; 打开书本。    &gt; 打开电灯。</code></pre><p>显示效果：</p><ul><li>阅读的方法:<blockquote><p>打开书本。<br>打开电灯。</p></blockquote></li></ul><h4 id="5-7-包含代码区块的引用"><a href="#5-7-包含代码区块的引用" class="headerlink" title="5.7. 包含代码区块的引用"></a>5.7. 包含代码区块的引用</h4><p>语法说明： </p><pre><code>如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：</code></pre><ul><li><p>一列表项包含一个列表区块：</p><p>   &lt;代码写在这&gt;</p></li></ul><h4 id="5-8-一个特殊情况"><a href="#5-8-一个特殊情况" class="headerlink" title="5.8. 一个特殊情况"></a>5.8. 一个特殊情况</h4><p>在特殊情况下，项目列表很可能会不小心产生，像是下面这样的写法：</p><pre><code>1986. What a great season.</code></pre><p>会显示成：</p><ol start="1986"><li>What a great season.</li></ol><p>换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠：</p><pre><code>1986\. What a great season.</code></pre><p>会显示成：</p><p>1986. What a great season.</p><h4 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a><strong>6. 引用</strong></h4><p>语法说明：</p><pre><code>引用需要在被引用的文本前加上&gt;符号。</code></pre><p>代码：</p><pre><code>&gt; 这是一个有两段文字的引用,&gt; 无意义的占行文字1.&gt; 无意义的占行文字2.&gt; &gt; 无意义的占行文字3.&gt; 无意义的占行文字4.</code></pre><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.</p><p>无意义的占行文字3.<br>无意义的占行文字4.</p></blockquote><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p><p>代码：</p><pre><code>&gt; 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2.&gt; 无意义的占行文字3.无意义的占行文字4.</code></pre><p>显示效果：</p><blockquote><p>这是一个有两段文字的引用,<br>无意义的占行文字1.<br>无意义的占行文字2.<br>无意义的占行文字3.<br>无意义的占行文字4.</p></blockquote><h4 id="6-1-引用的多层嵌套"><a href="#6-1-引用的多层嵌套" class="headerlink" title="6.1. 引用的多层嵌套"></a>6.1. 引用的多层嵌套</h4><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：</p><p>代码：</p><pre><code>&gt;&gt;&gt; 请问 Markdwon 怎么用？ - A&gt;&gt; 自己看教程！ - B&gt; 教程在哪？ - A</code></pre><p>显示效果：</p><blockquote><blockquote><blockquote><p>请问 Markdwon 怎么用？ - A<br>自己看教程！ - B<br>教程在哪？ - A</p></blockquote></blockquote></blockquote><h4 id="6-2-引用其它要素"><a href="#6-2-引用其它要素" class="headerlink" title="6.2. 引用其它要素"></a>6.2. 引用其它要素</h4><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p><p>代码：</p><pre><code>&gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><p>显示效果：</p><blockquote><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><p> return shell_exec(“echo $input | $markdown_script”);</p></blockquote><h4 id="7-插入图像"><a href="#7-插入图像" class="headerlink" title="7. 插入图像"></a><strong>7. 插入图像</strong></h4><blockquote><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p></blockquote><blockquote><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。</p></blockquote><h4 id="7-1-行内式"><a href="#7-1-行内式" class="headerlink" title="7.1. 行内式"></a>7.1. 行内式</h4><p>语法说明：</p><pre><code>![图片Alt](图片地址 “图片Title”)</code></pre><p>代码：</p><pre><code>markdown 语法： ![markdown 语法](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1503249365272&amp;di=4365c9b433a96044bb53b28c674ffdf3&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg &quot;markdown 语法&quot;)</code></pre><p>显示效果：</p><p>markdown 语法：<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1503249365272&di=4365c9b433a96044bb53b28c674ffdf3&imgtype=0&src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg" alt="markdown 语法" title="markdown 语法"></p><h4 id="7-2-参考式"><a href="#7-2-参考式" class="headerlink" title="7.2. 参考式"></a>7.2. 参考式</h4><p>语法说明：</p><pre><code>在文档要插入图片的地方写![图片Alt][标记]在文档的最后写上[标记]:图片地址 “Title”</code></pre><p>代码：</p><pre><code>markdown 语法： ![markdown 语法][markdown ][markdown ]:https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1503249365272&amp;di=4365c9b433a96044bb53b28c674ffdf3&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg &quot;markdown 语法&quot;</code></pre><p>显示效果：<br>markdown 语法：<br>![markdown 语法][markdown ]<br>[markdown ]:<a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1503249365272&amp;di=4365c9b433a96044bb53b28c674ffdf3&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg" target="_blank" rel="noopener">https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1503249365272&amp;di=4365c9b433a96044bb53b28c674ffdf3&amp;imgtype=0&amp;src=http%3A%2F%2Fimage.lxway.com%2Fupload%2F9%2Fc0%2F9c0c87edd315f32f61efce70cb403cc7.jpg</a> “markdown 语法”</p><h4 id="8-内容目录"><a href="#8-内容目录" class="headerlink" title="8. 内容目录"></a><strong>8. 内容目录</strong></h4><blockquote><p>在段落中填写 [TOC] 以显示全文内容的目录结构。</p></blockquote><blockquote><p>效果参见最上方的目录</p></blockquote><h4 id="9-注脚"><a href="#9-注脚" class="headerlink" title="9. 注脚"></a><strong>9. 注脚</strong></h4><p>语法说明：</p><pre><code>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。</code></pre><p>​    注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p><p>代码：</p><pre><code>使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文</code></pre><p>显示效果：</p><p>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p><p>[^2]:HyperText Markup Language 超文本标记语言</p><pre><code>注：脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。</code></pre><h4 id="10-LaTeX-公式"><a href="#10-LaTeX-公式" class="headerlink" title="10. LaTeX 公式"></a><strong>10. LaTeX 公式</strong></h4><h4 id="10-1-表示行内公式："><a href="#10-1-表示行内公式：" class="headerlink" title="10.1. $ 表示行内公式："></a>10.1. $ 表示行内公式：</h4><p>代码：</p><pre><code>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</code></pre><p>显示效果：</p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><h4 id="10-2-表示整行公式："><a href="#10-2-表示整行公式：" class="headerlink" title="10.2 $ 表示整行公式："></a>10.2 $ 表示整行公式：</h4><p>代码：</p><pre><code>$$\sum_{i=1}^n a_i=0$$$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$$$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$</code></pre><p>显示效果：<br>$$\sum_{i=1}^n a_i=0$$<br>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$<br>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><h4 id="11-流程图"><a href="#11-流程图" class="headerlink" title="11. 流程图"></a><strong>11. 流程图</strong></h4><p>代码：</p><pre><code>​```mermaidflowchatst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><pre><code>显示效果：​```mermaidflowchatst=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><h4 id="12-表格"><a href="#12-表格" class="headerlink" title="12 .表格"></a><strong>12 .表格</strong></h4><p>语法说明：</p><pre><code>不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。第二行还可以为不同的列指定对齐方向。默认为左对齐，在-右边加上:就右对齐。</code></pre><p>代码：</p><p>简单方式写表格：</p><pre><code>学号|姓名|分数-|-|-小明|男|75小红|女|79小陆|男|92</code></pre><p>原生方式写表格：</p><pre><code>|学号|姓名|分数||-|-|-||小明|男|75||小红|女|79||小陆|男|92|</code></pre><p>为表格第二列指定方向：</p><pre><code>产品|价格-|-:Leanote 高级账号|60元/年Leanote 超级账号|120元/年</code></pre><p>显示效果： </p><pre><code>简单方式写表格：</code></pre><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><pre><code>原生方式写表格：</code></pre><table><thead><tr><th>学号</th><th>姓名</th><th>分数</th></tr></thead><tbody><tr><td>小明</td><td>男</td><td>75</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>92</td></tr></tbody></table><pre><code>为表格第二列指定方向：</code></pre><table><thead><tr><th>产品</th><th align="right">价格</th></tr></thead><tbody><tr><td>Leanote 高级账号</td><td align="right">60元/年</td></tr><tr><td>Leanote 超级账号</td><td align="right">120元/年</td></tr><tr><td>#### <strong>13. 分隔线</strong></td><td align="right"></td></tr></tbody></table><blockquote><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p></blockquote><p>代码：</p><pre><code>* * *********- - ----------------------------------------</code></pre><p>显示效果都一样：</p><h4 id="14-代码"><a href="#14-代码" class="headerlink" title="14. 代码"></a><strong>14. 代码</strong></h4><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(Tab), 另一种是利用”`”符号（一般在ESC键下方）包裹代码。</p><p>语法说明：</p><pre><code>插入行内代码，即插入一个单词或者一句代码的情况，使用`code`这样的形式插入。插入多行代码，可以使用缩进或者“` code “`,具体看示例。注意： 缩进式插入前方必须有空行</code></pre><p>####8.1. 行内式</p><p>代码：</p><pre><code>C语言里的函数 `scanf()` 怎么使用？</code></pre><p>显示效果：</p><p>C语言里的函数 <code>scanf()</code> 怎么使用？</p><p>####8.2. 缩进式多行代码</p><blockquote><p>缩进 4 个空格或是 1 个制表符</p></blockquote><blockquote><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p></blockquote><p>代码：</p><pre><code>    #include &lt;stdio.h&gt;    int main(void)    {        printf(&quot;Hello world\n&quot;);    }</code></pre><p>显示效果：</p><pre><code>    #include &lt;stdio.h&gt;    int main(void)    {        printf(&quot;Hello world\n&quot;);    }</code></pre><p>####8.3. 用六个`包裹多行代码</p><p>代码：</p><pre><code></code></pre><p>#include &lt;stdio.h&gt;<br>int main(void)<br>{<br>    printf(“Hello world\n”);<br>}</p><pre><code></code></pre><p>显示效果：</p><pre><code>#include &lt;stdio.h&gt;int main(void){    printf(&quot;Hello world\n&quot;);}</code></pre><p>####8.4. HTML 原始码</p><blockquote><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理，例如：</p></blockquote><p>代码：</p><p>第一个例子：</p><pre><code>&lt;div class=&quot;footer&quot;&gt;   © 2004 Foo Corporation&lt;/div&gt;</code></pre><p>第二个例子：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><p>显示效果:</p><pre><code>第一个例子：</code></pre><div class="footer">   © 2004 Foo Corporation</div><pre><code>第二个例子：</code></pre><table>    <tr>        <th rowspan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>李强</td>        <td>张明</td>        <td>王平</td>    </tr></table>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面向对象</title>
      <link href="/2020/07/18/java-mian-xiang-dui-xiang/"/>
      <url>/2020/07/18/java-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="一、面向对象（OOP）"><a href="#一、面向对象（OOP）" class="headerlink" title="一、面向对象（OOP）"></a>一、面向对象（OOP）</h1><blockquote><p>本质是以类的方式组织代码，以对象的方式组织数据。</p></blockquote><p><strong>面向过程Vs面向对象</strong></p><ol><li>区别<ul><li>面向过程：事物比较简单，可以用线性思维去解决（第一步做什么，接下来做什么…)</li><li>面向对象：事物比较复杂，使用简单的线性思维无法解决</li></ul></li><li>共同点 <ul><li>面向过程和面向对象都是解决实际问题的一种思维方式</li><li>二者相辅相成，并不是对立的。解决复杂问题，通过面向对象可以方便我们从宏观上把握复杂的关系，便于我们分析整个系统；具体到微观操作，仍然使用面向过程方式来处理。</li></ul></li></ol><h1 id="二、类和对象"><a href="#二、类和对象" class="headerlink" title="二、类和对象"></a>二、类和对象</h1><h2 id="1-类（Class"><a href="#1-类（Class" class="headerlink" title="1. 类（Class)"></a>1. 类（Class)</h2><blockquote><p>类是具有共同属性的一组对象，是创建对象的模板或蓝图，是一个逻辑实体。</p></blockquote><h3 id="1-1-接口-Interface"><a href="#1-1-接口-Interface" class="headerlink" title="1.1 接口 (Interface)"></a>1.1 接口 (Interface)</h3><blockquote><p>接口：就是比“抽象类”还要抽象的“抽象类”，可以更加规范对子类进行约束。（接口就是规范，定义一组规则）</p><p>全面专业的实现：规范和具体实现的分离。</p></blockquote><p><strong>面向接口编程 vs 实现接口编程</strong></p><p>项目的具体需求是多变的，我们必须以不变应万变才能从容开发。</p><p><strong>Example</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInterface</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TestInterface.test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyInterface i<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TestInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        i<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//接口中只有常量、抽象方法，实现设计与实现的分离</span><span class="token keyword">interface</span> <span class="token class-name">MyInterface</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">,</span>B<span class="token punctuation">{</span>    <span class="token keyword">int</span> NUM<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//接口中上面语句等同于下面的语句，编译器添加 public static final</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUM1<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//接口中，</span>    <span class="token comment" spellcheck="true">//void test() == public static void test()</span><span class="token punctuation">}</span></code></pre><p><strong>小结：</strong></p><ul><li>子类通过implements来实现接口中的规范</li><li>接口不能创建实例，但可以用于声明引用变量类型</li><li>一个类实现了接口，必须实现该接口中的所有方法，且这些方法只能是public</li><li>接口支持多继承</li></ul><h4 id="1-1-1-回调-（CallBack）"><a href="#1-1-1-回调-（CallBack）" class="headerlink" title="1.1.1. 回调 （CallBack）"></a>1.1.1. 回调 （CallBack）</h4><blockquote><p>CallBack : Hook(钩子函数)</p></blockquote><p><strong>回调的实现:</strong></p><ol><li>Callback</li><li>Hook</li><li>模板方法模式</li></ol><h3 id="1-2-抽象类-（Abstract"><a href="#1-2-抽象类-（Abstract" class="headerlink" title="1.2 抽象类 （Abstract)"></a>1.2 抽象类 （Abstract)</h3><blockquote><p>抽象类只有声明，没有实现</p><p>抽象类是一种模板模式，抽象类为所有子类提供一个通用模板，子类可以拓展。</p><p>通过抽象类，我们可以严格的限制子类，使子类之间更加通用</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestAbstract</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Animal a=new Animal();  //错误: Animal是抽象的; 无法实例化</span>        Animal a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a<span class="token punctuation">.</span><span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//a.voice();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">breath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"呼吸"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//voice();</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"喵喵喵"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//breath();</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//错误: Cat不是抽象的, 并且未覆盖Animal中的抽象方法voice()</span><span class="token punctuation">}</span></code></pre><p><strong>抽象类要点：</strong></p><ul><li>有抽象方法的类只能定义成抽象类</li><li>抽象类不能实例化，即不能用new来实例化抽象类</li><li>抽象类可以包含属性、方法、构造器，但只能用来被子类调用</li><li>抽象类只能用于继承</li><li>抽象方法必须被子类实现</li></ul><h3 id="1-3-管理"><a href="#1-3-管理" class="headerlink" title="1.3 管理"></a>1.3 管理</h3><h4 id="1-3-1-Java包-（Package）"><a href="#1-3-1-Java包-（Package）" class="headerlink" title="1.3.1 Java包 （Package）"></a>1.3.1 Java包 （Package）</h4><ul><li><p>为何使用Package :</p><ol><li>解决类之间的重名问题</li><li>为了方便管理：合适的类位于合适的包名</li></ol></li><li><p>如何使用 :</p><ol><li>通常是类的第一句非注释语句</li><li>域名倒着写，再加上模块名，并于内部管理类</li></ol></li></ul><p><strong>注：</strong>com.gao和com.gao.car,这两个包没有包含关系，是完全独立的。（只是逻辑上看似后者是前者的一部分）</p><h4 id="1-3-2-Import"><a href="#1-3-2-Import" class="headerlink" title="1.3.2 Import"></a>1.3.2 Import</h4><h4 id="1-3-3-JDK中常用包"><a href="#1-3-3-JDK中常用包" class="headerlink" title="1.3.3 JDK中常用包"></a>1.3.3 JDK中常用包</h4><ul><li><p><strong>java.lang</strong>（language)</p><p>包含一些Java语言的核心类，如String，Math，Integer，System和Thread，提供常用功能</p></li><li><p><strong>java.awt</strong></p><p>包含抽象窗口工具集（abstract window toolkits）的多个类，这些类用来创建和管理程序的GUI</p></li><li><p><strong>java.net</strong></p><p>包含执行网络相关的操作类</p></li><li><p><strong>java.io</strong></p><p>包含能提供多种IO操作的类</p></li><li><p><strong>java.util</strong></p><p>包含一些实用的工具类，如定义系统特性，使用日期等</p></li></ul><h3 id="1-4-包含"><a href="#1-4-包含" class="headerlink" title="1.4 包含"></a>1.4 包含</h3><ul><li><p>字段</p></li><li><p>方法</p></li><li><p>构造函数</p></li><li><p>代码块</p></li><li><p>嵌套类和接口</p></li></ul><p>example :</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">int</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//每个编译单元（文件）都只能有一个public类.</span><span class="token comment" spellcheck="true">//这表示，每个编译单元都有单一的公共接口，用public类来表现。</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过加载器 Class Loader加载Student类，将类的信息存放在方法区</span>        Student stu<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stu<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"enosh"</span><span class="token punctuation">;</span>        stu<span class="token punctuation">.</span>age<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//"anshun"、20均是常量，存放到方法区中的常量池</span>        <span class="token comment" spellcheck="true">//而堆中对象的属性则存放对应的地址</span>        String str<span class="token operator">=</span><span class="token string">"enosh"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token operator">==</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//结果为true，即str与name指向同一个内存地址</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1-4-1-类的属性（Field）"><a href="#1-4-1-类的属性（Field）" class="headerlink" title="1.4.1 类的属性（Field）"></a>1.4.1 类的属性（Field）</h4><blockquote><p>属性：field，或者叫做成员变量</p></blockquote><ol><li>属性用于定义该类或改对象包含的数据或者说静态属性。</li><li>属性的作用范围是整个类体。</li><li>在定义成员变量时可以对其初始化，如果不对其初始化，Java使用默认值初始化。</li></ol><p><strong>类的变量类型</strong></p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>    ：类变量也声明在类中，方法体之外，但必须声明为static类型。</li></ul><h4 id="1-4-2-类的方法-Method"><a href="#1-4-2-类的方法-Method" class="headerlink" title="1.4.2 类的方法 (Method)"></a>1.4.2 类的方法 (Method)</h4><blockquote><p>在java中的方法类似函数，用于暴露对象的行为。</p></blockquote><p><strong>方法的优点</strong></p><ul><li>代码可重用性</li><li>代码优化</li></ul><p><strong>方法的重载 （Overload）</strong></p><blockquote><p>方法的重载是指一个类中可以定义有相同的名字，但参数不同的多个方法。调用时，会根据不同的参数表选择对应的方法。和普通方法一样，构造函数也可以重载。</p></blockquote><p>两同三不同:</p><ul><li>同一类，同一个方法名</li><li>参数表不同（类型、个数、顺序）</li></ul><p><strong>方法的重写 （Override）</strong></p><ul><li>子类中可以根据需要对基类中继承的方法进行重写</li><li>从写方法和被重写方法具有相同方法名、参数列表和返回类型</li><li>重写方法不能使用比被重写方法更严格的访问权限（由于多态）</li></ul><h4 id="1-4-3-构造方法-Constructor"><a href="#1-4-3-构造方法-Constructor" class="headerlink" title="1.4.3 构造方法 (Constructor)"></a>1.4.3 构造方法 (Constructor)</h4><blockquote><p>构造方法又称构造器，用于构建该类的实例</p></blockquote><p><strong>Constructor是一种特殊的方法：</strong></p><ul><li>通过new关键字调用</li><li>构造器虽然有返回值，但不能自定义返回值，返回类型是本类</li><li>如果我们没有定义构造器，则系统将会自动定义一个无参构造函数（如果已经添加构造器，则编译器不会添加）</li><li>构造器的方法名必须与类名一致</li></ul><p>example:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestConstructor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//Point p=new Point();  //错误: 无法将类 Point中的构造器 Point应用到给定类型;</span>        Point p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token operator">=</span>x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token operator">=</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="2-对象（Object"><a href="#2-对象（Object" class="headerlink" title="2. 对象（Object)"></a>2. 对象（Object)</h2><h3 id="2-1-引用类型（Reference）"><a href="#2-1-引用类型（Reference）" class="headerlink" title="2.1 引用类型（Reference）"></a>2.1 引用类型（Reference）</h3><ul><li>Java语言中除了基本类型之外的变量类型都称之为引用类型</li><li>Java中的对象通过引用对其进行操作</li></ul><h3 id="2-2-this"><a href="#2-2-this" class="headerlink" title="2.2 this"></a>2.2 this</h3><blockquote><p>隐式参数 : 普通方法中默认传入一个参数，即this。</p><p>类初始化存储于方法区，所有该类对象共用这一份代码，调用时传入this，以确定哪个对象</p></blockquote><ul><li>普通方法中：this总是指向调用该方法的对象 </li><li>构造方法中：this总是指向正要初始化的对象</li><li>this不能用于static方法（static方法不传递this参数）</li></ul><p><strong>Example</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">{</span>    String name<span class="token punctuation">;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//通过this调用其它方法</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//this();  //错误: 对this的调用必须是构造器中的第一个语句</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">/*Student this*/</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//传递隐式的参数this</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"anshun"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"学习"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-3-static"><a href="#2-3-static" class="headerlink" title="2.3 static"></a>2.3 static</h3><blockquote><p>区分类的变量和对象的变量，static对象从属于类，创建对象时不会存储static成员。</p></blockquote><ol><li><p>在类中，用static声明的成员变量称之为静态成员变量，或类属性、类变量</p><ul><li>它为该类的公共变量，属于类，被类的所有实例共享，在类被载入时被显示初始化</li><li>对该类的所有对象来说，static成员变量只有一份，被该类所有对象共享</li><li>static变量存储于方法区中</li></ul></li><li><p>用static声明的方法称作静态方法</p><ul><li>不需要对象就可以直接调用</li><li>在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员，而非static的成员可以访问和调用static成员。</li></ul></li></ol><p><strong>静态初始化块</strong></p><ul><li>如果希望加载后，对整个类进行某些初始化操作，可以使用static初始化块</li><li>是类初始化时执行，不是创建对象时</li><li>静态初始化块不能访问非static成员</li><li>执行顺序：上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块。</li></ul><h3 id="2-4-Final"><a href="#2-4-Final" class="headerlink" title="2.4 Final"></a>2.4 Final</h3><ul><li><strong>修饰变量：</strong>常量，只能初始化一次，类似cpp中的constant</li><li><strong>修饰方法：</strong>改方法不可以被子类重写，但可以被重载</li><li><strong>修饰类：</strong>修饰的类不能有子类，即不能被继承，如Math、String</li></ul><h3 id="2-5-内存结构"><a href="#2-5-内存结构" class="headerlink" title="2.5 内存结构"></a>2.5 内存结构</h3><blockquote><p>待补充</p></blockquote><h1 id="三、三大基本特征"><a href="#三、三大基本特征" class="headerlink" title="三、三大基本特征"></a>三、三大基本特征</h1><h2 id="1-继承-（Inherit"><a href="#1-继承-（Inherit" class="headerlink" title="1. 继承 （Inherit)"></a>1. 继承 （Inherit)</h2><blockquote><ol><li>类是对对象的抽象，OOD,继承是对某一批类的抽象，从而实现对现实世界更好的建模</li><li>提高代码的复用性，OOP</li><li>extends：拓展</li></ol></blockquote><p><strong>小结：</strong></p><ul><li>子类继承父类，可以得到除父类构造方法以外的全部属性和方法</li><li>Java中只有单继承，但可以用接口实现多继承</li><li>如果一个类没有调用extends，则它的父类是java.lang.Object</li></ul><h3 id="1-1-Object"><a href="#1-1-Object" class="headerlink" title="1.1 Object"></a>1.1 Object</h3><h3 id="1-2-Super"><a href="#1-2-Super" class="headerlink" title="1.2 Super"></a>1.2 Super</h3><blockquote><p>super是直接父类对象的引用，可以通过super来访问父类中被子类覆盖的方法或属性</p></blockquote><ul><li>普通方法：没有顺序限制，可以随便调用</li><li>构造方法：任何类的构造函数中，若是构造函数第一行没有显式的调用super(..)，那么Java默认都会调用super()作为父类的初始化函数。</li></ul><h3 id="1-3-方法重写-（Override）"><a href="#1-3-方法重写-（Override）" class="headerlink" title="1.3 方法重写 （Override）"></a>1.3 方法重写 （Override）</h3><ul><li>子类中可以根据需要对基类中继承的方法进行重写</li><li>从写方法和被重写方法具有相同方法名、参数列表和返回类型</li><li>重写方法不能使用比被重写方法更严格的访问权限（由于多态）</li></ul><h3 id="1-4-组合"><a href="#1-4-组合" class="headerlink" title="1.4 组合"></a>1.4 组合</h3><p><strong>继承 vs 组合：</strong></p><ul><li>is-a 关系使用继承</li><li>has-a 关系使用组合</li></ul><h2 id="2-封装-Encapsulation"><a href="#2-封装-Encapsulation" class="headerlink" title="2. 封装 (Encapsulation )"></a>2. 封装 (Encapsulation )</h2><p><strong>封装的作用及含义:</strong></p><ul><li>隐藏对象内部的复杂性、只对外公开简单的接口，以便外界调用，从而提高系统的可拓展性、可维护性。</li></ul><p>高聚合，低耦合:</p><ul><li>高聚合就是类的内部数据操作细节自己完成，不允许外接干涉</li></ul><p><strong>控制符</strong>：</p><table><thead><tr><th></th><th align="center">同一个类</th><th align="center">同一个包</th><th align="center">子类</th><th align="center">所有类</th></tr></thead><tbody><tr><td>private</td><td align="center">*</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>default</td><td align="center">*</td><td align="center">*</td><td align="center"></td><td align="center"></td></tr><tr><td>protected</td><td align="center">*</td><td align="center">*</td><td align="center">*</td><td align="center"></td></tr><tr><td>public</td><td align="center">*</td><td align="center">*</td><td align="center">*</td><td align="center">*</td></tr></tbody></table><h2 id="3-多态（polymorphism）"><a href="#3-多态（polymorphism）" class="headerlink" title="3. 多态（polymorphism）"></a>3. 多态（polymorphism）</h2><blockquote><p> 多态是OOP中的一个重要的特征，主要实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间。</p></blockquote><p><strong>Java如何实现多态</strong></p><p>引用变量的两种类型：</p><ul><li>编译时类型（模糊点，一般是一个父类）：由声明时的类型决定</li><li>执行时类型（运行时，具体是哪个子类就是那个子类）：由实际对象的类型决定</li><li>编译时，变量声明的什么类型就是什么类型，执行时，创建的什么类型对象就是什么类型</li></ul><p><strong>多态的三个必要条件</strong></p><ul><li>要有继承</li><li>要有方法重写</li><li>父类引用指向子类对象</li></ul><p><strong>Example</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestPolymorphism</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//不使用多态</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCat</span><span class="token punctuation">(</span>Cat a<span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testDog</span><span class="token punctuation">(</span>Dog a<span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testPig</span><span class="token punctuation">(</span>Pig a<span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//使用多态</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testAnimal</span><span class="token punctuation">(</span>Animal a<span class="token punctuation">)</span><span class="token punctuation">{</span>        a<span class="token punctuation">.</span><span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">testCat</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Animal a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//编译时，a声明的是Animal类型，就会去Animal类中查找相应的成员</span>        <span class="token comment" spellcheck="true">//       如果没有改成员，则编译无法通过</span>        <span class="token comment" spellcheck="true">//执行过程中，a指向的是一个Cat类的实例对象，则a的类型就是Cat</span>        <span class="token comment" spellcheck="true">//a.play();//如法通过编译</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Cat<span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">testAnimal</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//父类的引用指向一个子类对象</span>        <span class="token function">testAnimal</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    String str<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"普通动物叫声"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"喵喵喵"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"上树"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"汪汪汪"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Pig</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">voice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"哼哼哼"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础知识</title>
      <link href="/2020/07/18/java-ji-chu-zhi-shi/"/>
      <url>/2020/07/18/java-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java-简介"><a href="#一、Java-简介" class="headerlink" title="一、Java 简介"></a>一、Java 简介</h1><blockquote><ol><li><p>Java是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。</p></li><li><p>Java具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java可以编写桌面应用程序、Web应用程序、分布式系统和嵌入式系统应用程序等。</p></li></ol></blockquote><h2 id="Java-的三个体系"><a href="#Java-的三个体系" class="headerlink" title="Java 的三个体系"></a>Java 的三个体系</h2><ul><li><strong>Java SE（Java Platform，Standard Edition）</strong>：Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。</li><li><strong>Java EE（Java Platform，Enterprise Edition）：</strong>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。</li><li><strong>Java ME（Java Platform，Micro Edition）：</strong>Java ME以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h2 id="Java-的主要特性"><a href="#Java-的主要特性" class="headerlink" title="Java 的主要特性"></a>Java 的主要特性</h2><ul><li><p><strong>Java语言是简单的：</strong></p><p>Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</p></li><li><p><strong>Java语言是面向对象的：</strong></p><p>Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</p></li><li><p><strong>Java语言是分布式的：</strong></p><p>Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</p></li><li><p><strong>Java语言是健壮的：</strong></p><p>Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</p></li><li><p><strong>Java语言是安全的：</strong></p><p>Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p></li><li><p><strong>Java语言是体系结构中立的：</strong></p><p>Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</p></li><li><p><strong>Java语言是可移植的：</strong></p><p>这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</p></li><li><p><strong>Java语言是解释型的：</strong></p><p>如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</p></li><li><p><strong>Java是高性能的：</strong></p><p>与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</p></li><li><p><strong>Java语言是多线程的：</strong></p><p>在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子类将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</p></li><li><p><strong>Java语言是动态的：</strong></p><p>Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</p></li></ul><h1 id="二、Java-基础语法"><a href="#二、Java-基础语法" class="headerlink" title="二、Java 基础语法"></a>二、Java 基础语法</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li><strong>大小写敏感</strong>：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>主方法入口</strong>：所有的Java 程序由<strong>public static void main(String args[])</strong>方法开始执行。</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><blockquote><p>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p></blockquote><p><strong>注意：</strong></p><ol><li>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是任何字符的组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li></ol><p><strong>Example:</strong></p><ul><li>合法标识符举例：age、$salary、_value、<em>1</em>value</li><li>非法标识符举例：123abc、-salary</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>数组是储存在堆上的对象，可以保存多个同类型变量，这些变量类型既可以存储基本数据类型，也可以存储引用数据类型。</p></blockquote><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a><strong>一维数组</strong></h3><p><strong>数组的格式</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a；     定义了一个<span class="token keyword">int</span>类型的数组a；<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      定义了一个<span class="token keyword">int</span>类型的a数组；<span class="token comment" spellcheck="true">//推荐使用第一种定义方式。</span></code></pre><p><strong>数组的初始化</strong></p><p>所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。Java中的数组必须先初始化,然后才能使用。</p><ul><li><strong>动态初始化：</strong> 只指定长度，由系统给出初始化值。</li><li><strong>静态初始化：</strong> 给出初始化值，不用new关键字完成，由系统决定长度。</li><li><strong>默认初始化：</strong>数组是引用类型，它的元素相当于类的成员变量，因此数组分配空间后，每个元素也被按照成员变量的规则被隐士初始化。</li></ul><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a><strong>二维数组</strong></h3><p><strong>定义格式</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定义了一个二维数组arr</span><span class="token comment" spellcheck="true">//这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]</span><span class="token comment" spellcheck="true">//每个一维数组有2个元素，可以通过arr[m][n]来获取,表示获取第m+1个一维数组的第n+1个元素</span></code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><blockquote><p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。</p></blockquote><h1 id="三、Java-数据类型"><a href="#三、Java-数据类型" class="headerlink" title="三、Java 数据类型"></a>三、Java 数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><blockquote><p>Java语言内置了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p></blockquote><table><thead><tr><th>类型</th><th>最小值</th><th>最大值</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>byte</td><td>-128（-2^7）</td><td>127（2^7-1）</td><td>0</td><td>8位、有符号的，以二进制补码表示的整数</td></tr><tr><td>short</td><td>-2^15</td><td>2^15 - 1</td><td>0</td><td>16位、有符号的以二进制补码表示的整数</td></tr><tr><td>int</td><td>-2^31</td><td>2^31 - 1</td><td>0</td><td>32位、有符号的以二进制补码表示的整数</td></tr><tr><td>long</td><td>-2^63</td><td>2^63 -1</td><td>0L</td><td>64位、有符号的以二进制补码表示的整数</td></tr><tr><td>float</td><td></td><td></td><td>0.0f</td><td>单精度、32位、符合IEEE 754标准的浮点数</td></tr><tr><td>double</td><td></td><td></td><td>0.0d</td><td>双精度、64位、符合IEEE 754标准的浮点数</td></tr><tr><td>boolean</td><td></td><td></td><td>false</td><td>表示一位的信息</td></tr><tr><td>char</td><td>‘\u0000’ (0)</td><td>‘\uffff’ (65,535)</td><td></td><td>一个单一的16位Unicode字符</td></tr></tbody></table><ul><li><p>浮点数的默认类型为double类型，不能用来表示精确的值，如货币。但float在储存大型浮点数组的时候可节省内存空间。</p></li><li><p><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" target="_blank" rel="noopener">Primitive Data Types</a></p></li></ul><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><blockquote><p>java为每种基本类型都提供了对应的封装类型，分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean。引用类型是一种对象类型,它的值是指向内存空间的引用，就是地址。</p></blockquote><ul><li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，变量一旦声明后，类型就不能被改变了。</li><li>基本数据类型的变量是存储在栈内存中，而引用类型变量存储在栈内存中，保存的是实际对象在堆内存中的地址，实际对象中保存这内容。</li><li>对象、String、数组都是引用数据类型。</li><li>所有引用类型的默认值都是null。</li><li>一个引用变量可以用来引用任何与之兼容的类型。</li></ul><h2 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h2><blockquote><p>在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情形。为了解决这个问题，Java语言为每一个内置数据类型提供了对应的包装类。所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类Number的子类。</p></blockquote><p><img src="https://7n.w3cschool.cn/attachments/image/20160401/1459506097805010.jpg" alt=""></p><p><strong>Math类</strong></p><p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。</p><p>Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><blockquote><p>Java 从 jdk1.5 开始引入自动装箱和拆箱,使得基本数据类型与引用类型之间相互转换变得简单。</p></blockquote><ul><li><strong>自动装箱：</strong>java自动将原始类型转化为引用类型的过程，自动装箱时编译器会调用valueOf()方法,将原始类型转化为对象类型。</li><li><strong>自动拆箱：</strong>java自动将引用类型转化为原始类型的过程，自动拆箱时编译器会调用intValue(),doubleValue()这类的方法将对象转换成原始类型值。</li></ul><h3 id="主要的发生情况"><a href="#主要的发生情况" class="headerlink" title="主要的发生情况"></a>主要的发生情况</h3><p>一是赋值时: </p><pre class=" language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动装箱</span><span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动拆箱</span></code></pre><p>二是方法调用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Integer <span class="token function">query</span><span class="token punctuation">(</span>Integer a<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">query</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动装箱</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//自动拆箱</span></code></pre><h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><ul><li><strong>程序性能：</strong>由于装箱会隐式地创建对象创建，因此千万不要在一个循环中进行自动装箱的操作，下面就是一个循环中进行自动装箱的例子，会额外创建多余的对象,增加GC的压力,影响程序的性能。</li></ul><pre class=" language-java"><code class="language-java">Integer sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   sum<span class="token operator">+=</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>空指针异常：</strong></li></ul><pre class=" language-java"><code class="language-java">Object obj <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">)</span>obj<span class="token punctuation">;</span></code></pre><h3 id="对象比较-缓存池问题"><a href="#对象比较-缓存池问题" class="headerlink" title="对象比较(缓存池问题)"></a>对象比较(缓存池问题)</h3><pre class=" language-java"><code class="language-java">Integer a <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span><span class="token keyword">int</span> b<span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>Integer c <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>Integer d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">120</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true    t1</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//true    t2</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//false   t3</span>Integer e <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>Integer f <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e <span class="token operator">==</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//false   t4</span></code></pre><ol><li>t1产生的原因是编译器编译时会调用intValue()自动的将a进行了拆箱，结果肯定是true; </li><li>t3结果无论如何都不会相等的，因为new Integer(120)构造器会创建新的对象。</li><li>对于t2和t4，查看jdk的源码：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发现在 Java 8 中，Integer 缓存池的大小默认为 -128~127，对于-128~127之间的值会取缓存中的引用,通过缓存经常请求的值而显著提高空间和时间性能。 这就能解释t2结果返回true，而t4由于128不在缓存区间内，编译器调用valueOf方法会重新创建新的对象，两个不同的对象返回false。</p><p><strong>基本类型对应的缓冲池</strong></p><ul><li>boolean values true and false</li><li>all byte values</li><li>short  and int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><blockquote><p>整型、实型(常量)、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p></blockquote><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><blockquote><p>数字表示范围小的数据类型可以自动转换成范围大的数据类型。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token keyword">long</span> l <span class="token operator">=</span> i<span class="token punctuation">;</span></code></pre><p>自动转换关系图：</p><p><a href="https://postimg.cc/4KVrdqt5" target="_blank" rel="noopener"><img src="https://i.postimg.cc/HLhHSCkf/Java-Snipaste-2019-03-19-21-39-43.png" alt="Java-Snipaste-2019-03-19-21-39-43.png"></a></p><p>实线表示自动转换时不会造成数据丢失，虚线则可能会出现数据丢失问题。</p><p><strong>注意：</strong></p><ul><li>自动转换也要小心数据溢出问题</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100000000</span><span class="token punctuation">;</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">1999</span><span class="token punctuation">;</span><span class="token keyword">long</span> totalPrice <span class="token operator">=</span> count <span class="token operator">*</span> price<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//编译没任何问题，但结果却输出的是负数，</span><span class="token comment" spellcheck="true">//这是因为两个 int 相乘得到的结果是 int, 相乘的结果超出了 int 的代表范围。</span><span class="token comment" spellcheck="true">//这种情况，一般把第一个数据转换成范围大的数据类型再和其他的数据进行运算。</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">100000000</span><span class="token punctuation">;</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">1999</span><span class="token punctuation">;</span><span class="token keyword">long</span> totalPrice <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> count <span class="token operator">*</span> price<span class="token punctuation">;</span></code></pre><ul><li><strong>向下转换</strong>时可以直接将 int 常量字面量赋值给 byte、short、char 等数据类型，而不需要强制转换，只要该常量值不超过该类型的表示范围都能自动转换。</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">199</span><span class="token punctuation">;</span><span class="token keyword">int</span> i <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 199</span><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token number">10.24</span><span class="token punctuation">;</span><span class="token keyword">long</span> ll <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> d<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 10</span><span class="token comment" spellcheck="true">//以上的转换结果都在我们的预期之内，属于正常的转换和丢失精度的情况，下面的例子就一样属于数据溢出的情况。</span><span class="token keyword">int</span> ii <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span>ii<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//300 已经超出了 byte 类型表示的范围，所以会转换成一个毫无意义的数字。</span></code></pre><h3 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h3><blockquote><p>所谓类型提升就是指在多种不同数据类型的表达式中，类型会自动向范围表示大的值的数据类型提升。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">100000000</span><span class="token punctuation">;</span><span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">1999</span><span class="token punctuation">;</span><span class="token keyword">long</span> totalPrice <span class="token operator">=</span> price <span class="token operator">*</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//price 为 int 型，count 为 long 型，运算结果为 long 型，运算结果正常，没有出现溢出的情况。</span></code></pre><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p><ul><li><p>基本类型作为参数传递时，是传递值的拷贝，无论你怎么改变这个拷贝，原值是不会改变的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before change, n = "</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//Before change, n = 3</span>           <span class="token function">changeData</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After changeData(n), n = "</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//After changeData(n), n = 3</span>       <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">changeData</span><span class="token punctuation">(</span><span class="token keyword">int</span> nn<span class="token punctuation">)</span> <span class="token punctuation">{</span>           n <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>对象作为参数传递时，是把对象在内存中的地址拷贝了一份传给了参数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before change, sb = "</span> <span class="token operator">+</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Before change, sb = Hello</span>        <span class="token function">changeData</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After changeData(n), sb = "</span> <span class="token operator">+</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//After changeData(n), sb = Hi World!</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">changeData</span><span class="token punctuation">(</span>StringBuffer strBuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>        strBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"Hello "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before change, sb = "</span> <span class="token operator">+</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//Before change, sb = Hello</span>        <span class="token function">changeData</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After changeData(n), sb = "</span> <span class="token operator">+</span> sb<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//After changeData(n), sb = Hello</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">changeData</span><span class="token punctuation">(</span>StringBuffer strBuf<span class="token punctuation">)</span> <span class="token punctuation">{</span>        strBuf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"Hi "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        strBuf<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value" target="_blank" rel="noopener">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p><h1 id="四、Java-变量类型"><a href="#四、Java-变量类型" class="headerlink" title="四、Java 变量类型"></a>四、Java 变量类型</h1><blockquote><p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//type identifier [ = value][, identifier [= value] ...] ;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 声明三个int型整数：a、b、c。</span><span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> e<span class="token punctuation">,</span> f <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明三个整数并赋予初值。</span></code></pre></blockquote><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><blockquote><p>类的方法中的变量</p></blockquote><ul><li>局部变量声明在方法、构造方法或者语句块中；</li><li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li><li>访问修饰符不能用于局部变量；</li><li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li><li>局部变量是在栈上分配的;</li><li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li></ul><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><blockquote><p>独立于方法之外的变量，不过没有 static 修饰。</p></blockquote><ul><li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li><li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li><li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li><li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li><li>实例变量可以声明在使用前或者使用后；</li><li>访问修饰符可以修饰实例变量；</li><li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li><li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li><li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li></ul><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><blockquote><p>亦称静态变量，独立于方法之外的变量，用 static 修饰。</p></blockquote><ul><li>类变量也称为静态变量，在类中以static关键字声明，但必须在方法、构造方法和语句块之外；</li><li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝；</li><li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变；</li><li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量；</li><li>静态变量在程序开始时创建，在程序结束时销毁；</li><li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型；</li><li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化；</li><li>类变量被声明为public static final类型时，类变量名称必须使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致；</li><li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li></ul><h1 id="五、Java-修饰符"><a href="#五、Java-修饰符" class="headerlink" title="五、Java 修饰符"></a>五、Java 修饰符</h1><blockquote><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p><ol><li><strong>访问控制修饰符 :</strong> default, public , protected, private</li><li><strong>非访问控制修饰符 :</strong> final, abstract, static，synchronized 和 volatile</li></ol></blockquote><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><ul><li><p><strong>默认访问控制修饰符</strong></p><ol><li>使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。</li><li>接口里的变量都隐式声明为public static final,而接口里的方法默认情况下访问权限为public。</li></ol></li><li><p><strong>私有访问控制修饰符</strong></p><ol><li>私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private。</li><li>声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问。</li><li>Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</li></ol></li><li><p><strong>公有访问修饰符：</strong></p><ol><li>被声明为public的类、方法、构造方法和接口能够被任何其他类访问。</li><li>类所有的公有方法和变量都能被其子类继承。</li><li>Java程序的main() 方法必须设置成公有的，否则，Java解释器将不能运行该类。</li></ol></li><li><p><strong>受保护的访问修饰符</strong></p><ol><li>被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问，也能够被不同包中的子类访问。</li></ol></li></ul><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul><li>父类中声明为public的方法在子类中也必须为public。</li><li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public。不能声明为private。</li><li>父类中默认修饰符声明的方法，能够在子类中声明为private。</li><li>父类中声明为private的方法，不能够被继承。</li></ul><h2 id="非访问修饰符"><a href="#非访问修饰符" class="headerlink" title="非访问修饰符"></a>非访问修饰符</h2><blockquote><p>为了实现一些其他的功能，Java也提供了许多非访问修饰符。</p></blockquote><h3 id="static修饰符"><a href="#static修饰符" class="headerlink" title="static修饰符"></a>static修饰符</h3><blockquote><p>static修饰符，用来创建类方法和类变量。</p></blockquote><ul><li><strong>静态变量：</strong>static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。静态变量也被称为类变量。局部变量不能被声明为static变量。</li><li><strong>静态方法：</strong>static关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</li></ul><h3 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h3><blockquote><p>用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p></blockquote><ul><li><p><strong>final变量：</strong></p><ol><li>final变量能被显式地初始化并且只能初始化一次。被声明为final的对象的引用不能指向不同的对象。</li><li>但是final对象里的数据可以被改变。也就是说final对象的引用不能改变，但是里面的值可以改变。</li></ol></li><li><p><strong>final方法：</strong></p><ol><li><p>类中的Final方法可以被子类继承，但是不能被子类修改。</p></li><li><p>声明final方法的主要目的是防止该方法的内容被修改。</p></li></ol></li><li><p><strong>final类：</strong></p><ol><li>final类不能被继承，没有类能够继承final类的任何特性。</li></ol></li></ul><h3 id="abstract修饰符"><a href="#abstract修饰符" class="headerlink" title="abstract修饰符"></a>abstract修饰符</h3><ul><li><strong>抽象类：</strong><ol><li>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</li><li>一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</li><li>抽象类可以包含抽象方法和非抽象方法。</li></ol></li><li><strong>抽象方法：</strong><ol><li>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和static。</li><li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li><li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</li><li>抽象方法的声明以分号结尾，例如：public abstract sample();</li></ol></li></ul><h3 id="synchronized修饰符"><a href="#synchronized修饰符" class="headerlink" title="synchronized修饰符"></a>synchronized修饰符</h3><blockquote><p>synchronized关键字声明的方法同一时间只能被一个线程访问。Synchronized修饰符可以应用于四个访问修饰符。</p></blockquote><h3 id="volatile修饰符"><a href="#volatile修饰符" class="headerlink" title="volatile修饰符"></a>volatile修饰符</h3><blockquote><p>volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个volatile对象引用可能是null。</p></blockquote><h3 id="transient修饰符"><a href="#transient修饰符" class="headerlink" title="transient修饰符"></a>transient修饰符</h3><blockquote><p>序列化的对象包含被transient修饰的实例变量时，java虚拟机(JVM)跳过该特定的变量。</p></blockquote><p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">55</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// will not persist</span><span class="token keyword">public</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// will persist</span></code></pre><h1 id="六、Java-运算符"><a href="#六、Java-运算符" class="headerlink" title="六、Java 运算符"></a>六、Java 运算符</h1><blockquote><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。</p></blockquote><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><blockquote><p>变量A的值为10，变量B的值为20：</p></blockquote><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加法 - 相加运算符两侧的值</td><td>A + B等于30</td></tr><tr><td>-</td><td>减法 - 左操作数减去右操作数</td><td>A – B等于-10</td></tr><tr><td>*</td><td>乘法 - 相乘操作符两侧的值</td><td>A * B等于200</td></tr><tr><td>/</td><td>除法 - 左操作数除以右操作数</td><td>B / A等于2</td></tr><tr><td>％</td><td>取模 - 左操作数除以右操作数的余数</td><td>B%A等于0</td></tr><tr><td>++</td><td>自增 - 操作数的值增加1</td><td>B++ 或 ++B 等于 21</td></tr><tr><td>–</td><td>自减 - 操作数的值减少1</td><td>B– 或 –B 等于 19</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><blockquote><p>变量A的值为10，变量B的值为20：</p></blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>==</td><td>检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td>（A == B）为假(非真)。</td></tr><tr><td>!=</td><td>检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td>(A != B) 为真。</td></tr><tr><td>&gt;</td><td>检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td>（A&gt; B）非真。</td></tr><tr><td>&lt;</td><td>检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td>（A &lt;B）为真。</td></tr><tr><td>&gt; =</td><td>检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td>（A&gt; = B）为假。</td></tr><tr><td>&lt;=</td><td>检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td>（A &lt;= B）为真。</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><blockquote><p>变量A的值为60和变量B的值为13：</p></blockquote><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>＆</td><td>按位与操作符，当且仅当两个操作数的某一位都非0时候结果的该位才为1。</td><td>（A＆B），得到12，即0000 1100</td></tr><tr><td>|</td><td>按位或操作符，只要两个操作数的某一位有一个非0时候结果的该位就为1。</td><td>（A | B）得到61，即 0011 1101</td></tr><tr><td>^</td><td>按位异或操作符，两个操作数的某一位不相同时候结果的该位就为1。</td><td>（A ^ B）得到49，即 0011 0001</td></tr><tr><td>〜</td><td>按位补运算符翻转操作数的每一位。</td><td>（〜A）得到-60，即1100 0011</td></tr><tr><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A &lt;&lt; 2得到240，即 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A &gt;&gt; 2得到15即 1111</td></tr><tr><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2得到15即0000 1111</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><blockquote><p>布尔变量A为真，变量B为假</p></blockquote><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td>（A &amp;&amp; B）为假。</td></tr><tr><td>||</td><td>称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td>（A | | B）为真。</td></tr><tr><td>！</td><td>称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td>！（A &amp;&amp; B）为真。</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td>C = A + B将把A + B得到的值赋给C</td></tr><tr><td>+ =</td><td>加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数</td><td>C + = A等价于C = C + A</td></tr><tr><td>- =</td><td>减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数</td><td>C - = A等价于C = C -  A</td></tr><tr><td>* =</td><td>乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数</td><td>C * = A等价于C = C * A</td></tr><tr><td>/ =</td><td>除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数</td><td>C / = A等价于C = C / A</td></tr><tr><td>（％）=</td><td>取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数</td><td>C％= A等价于C = C％A</td></tr><tr><td>&lt;&lt; =</td><td>左移位赋值运算符</td><td>C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td>&gt;&gt; =</td><td>右移位赋值运算符</td><td>C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td>＆=</td><td>按位与赋值运算符</td><td>C＆= 2等价于C = C＆2</td></tr><tr><td>^ =</td><td>按位异或赋值操作符</td><td>C ^ = 2等价于C = C ^ 2</td></tr><tr><td>| =</td><td>按位或赋值操作符</td><td>C | = 2等价于C = C | 2</td></tr></tbody></table><h2 id="条件运算符（-）"><a href="#条件运算符（-）" class="headerlink" title="条件运算符（?:）"></a>条件运算符（?:）</h2><blockquote><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p></blockquote><pre class=" language-java"><code class="language-java">variable x <span class="token operator">=</span> <span class="token punctuation">(</span>expression<span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token keyword">if</span> <span class="token boolean">true</span> <span class="token operator">:</span> value <span class="token keyword">if</span> <span class="token boolean">false</span></code></pre><h2 id="instanceOf-运算符"><a href="#instanceOf-运算符" class="headerlink" title="instanceOf 运算符"></a>instanceOf 运算符</h2><blockquote><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//( Object reference variable ) instanceOf  (class/interface type)</span>String name <span class="token operator">=</span> <span class="token string">'James'</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> result <span class="token operator">=</span> name instanceOf <span class="token class-name">String</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 由于name是Strine类型，所以返回真</span></code></pre><p>如果被比较的对象兼容于右侧类型,该运算符仍然返回true。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token keyword">extends</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      Vehicle a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Car</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">boolean</span> result <span class="token operator">=</span>  a <span class="token keyword">instanceof</span> <span class="token class-name">Car</span><span class="token punctuation">;</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><blockquote><p>下表中的运算符优先级由上至下依次降低：</p></blockquote><table><thead><tr><th>类别</th><th>操作符</th><th>关联性</th></tr></thead><tbody><tr><td>后缀</td><td>() [] . (点操作符)</td><td>左到右</td></tr><tr><td>一元</td><td>+ + - ！〜</td><td>从右到左</td></tr><tr><td>乘性</td><td>* /％</td><td>左到右</td></tr><tr><td>加性</td><td>+ -</td><td>左到右</td></tr><tr><td>移位</td><td>&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td><td>左到右</td></tr><tr><td>关系</td><td>&gt;&gt; = &lt;&lt; =</td><td>左到右</td></tr><tr><td>相等</td><td>==  !=</td><td>左到右</td></tr><tr><td>按位与</td><td>＆</td><td>左到右</td></tr><tr><td>按位异或</td><td>^</td><td>左到右</td></tr><tr><td>按位或</td><td>|</td><td>左到右</td></tr><tr><td>逻辑与</td><td>&amp;&amp;</td><td>左到右</td></tr><tr><td>逻辑或</td><td>||</td><td>左到右</td></tr><tr><td>条件</td><td>？：</td><td>从右到左</td></tr><tr><td>赋值</td><td>= + = - = * = / =％= &gt;&gt; = &lt;&lt; =＆= ^ = | =</td><td>从右到左</td></tr><tr><td>逗号</td><td>，</td><td>左到右</td></tr></tbody></table><h1 id="七、Java-String-类"><a href="#七、Java-String-类" class="headerlink" title="七、Java String 类"></a>七、Java String 类</h1><blockquote><p>在 Java语言中有8种基本类型和一种比较特殊的类型<code>String</code>。由于<code>String</code>在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池（当然基础类型也有）。</p></blockquote><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><p>常量池就类似一个Java系统级别提供的缓存，指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的常量，也包括字符串常量。Java会确保一个字符串常量只有一个拷贝。</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"Programming"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Programming"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s3 <span class="token operator">=</span> <span class="token string">"Program"</span> <span class="token operator">+</span> <span class="token string">"ming"</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>String s5 <span class="token operator">=</span> <span class="token string">"Programming"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span>s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false 没有将返回值赋值给s2</span>s2<span class="token operator">=</span>s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//true</span></code></pre><ul><li>s1和s3中的”Programming”都是字符串常量，它们在编译期就被确定了，所以s1==s3为true；而”Program”和”ming”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，JVM对此做了一个优化，s3也同样在编译期就被解析为一个字符串常量，所以s3也是常量池中 ”Programming”的一个引用。 所以我们得出s5==s1==s3</li><li>用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。所以有s2！=s4</li><li>String对象的intern()方法会得到字符串对象在常量池中对应的版本的引用（如果常量池中有一个字符串与String对象的equals结果是true），如果常量池中没有对应的字符串，则该字符串将被添加到常量池中，然后返回常量池中字符串的引用。</li></ul><p><strong>补充：</strong>存在于.class文件中的常量池，在运行期被JVM装载，并且可以扩充。String的intern()方法就是扩充常量池的一个 方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用， 如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用。</p><h2 id="String是不可变的"><a href="#String是不可变的" class="headerlink" title="String是不可变的"></a>String是不可变的</h2><blockquote><p>String 是一个典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。</p></blockquote><ul><li><p>可以缓存Hash值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p></li><li><p>常量池的需要：如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p></li><li><p>线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p></li></ul><h2 id="equals-amp"><a href="#equals-amp" class="headerlink" title="equals() &amp; =="></a>equals() &amp; ==</h2><ul><li><p>String类已经重写过了equals方法，这对于String简单来说就是比较两字符串的Unicode序列是否相当，如果相等返回true。而==是比较两字符串的地址是否相同，也就是是否是同一个字符串的引用。</p></li><li><p>在符合数据类型中，则equals和==都是比较两对象的地址是否相同，除非重写equals，详见hashcode与equals的区别。</p></li></ul><h2 id="StringBuffer-amp-StringBuilder"><a href="#StringBuffer-amp-StringBuilder" class="headerlink" title="StringBuffer &amp; StringBuilder"></a>StringBuffer &amp; StringBuilder</h2><ul><li><p>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口。</p></li><li><p>其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组，JDK 9 以后是 byte）进行存储，不同点是StringBuffer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变。</p></li><li><p>两者对象在构造过程中，首先按照默认大小申请一个字符数组（这个大小是 16），由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容通过arraycopy复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</p></li><li><p><strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。</strong>区别仅在于最终的方法是否加了 synchronized，即三者的执行效率上 StringBuilder &gt; StringBuffer &gt; String 。</p></li></ul><p><strong>小结：</strong></p><ol><li><p>String适用于少量的字符串操作的情况。</p></li><li><p>StringBuilder适用于单线程下在字符缓冲区进行大量操作的情况。</p></li><li><p>StringBuffer适用多线程下在字符缓冲区进行大量操作的情况。</p></li></ol><h1 id="八、Object-方法"><a href="#八、Object-方法" class="headerlink" title="八、Object 方法"></a>八、Object 方法</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException</code></pre><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><ol><li><p><strong>等价关系</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//自反性</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">//对称性 </span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> y<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">//传递性 </span><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span>    x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true;</span><span class="token comment" spellcheck="true">//一致性，多次调用 equals() 方法结果不变</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">==</span> x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">//与 null 的比较</span><span class="token comment" spellcheck="true">//对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</span>x<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false;</span></code></pre></li></ol><ol start="2"><li><p><strong>等价与相等</strong></p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul></li><li><p><strong>实现</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EqualExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> z<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">EqualExample</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> o<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//检查是否为同一个对象的引用，如果是直接返回 true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> o<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//检查是否是同一个类型，如果不是，直接返回 false</span>        EqualExample that <span class="token operator">=</span> <span class="token punctuation">(</span>EqualExample<span class="token punctuation">)</span> o<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将 Object 对象进行转型</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> that<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//判断每个关键域是否相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">!=</span> that<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> z <span class="token operator">==</span> that<span class="token punctuation">.</span>z<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><ul><li>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</li><li>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</li></ul><h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h2><blockquote><p>默认返回 Example@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><ol><li><p><strong>cloneable</strong></p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p></li><li><p><strong>浅拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p></li><li><p><strong>深拷贝</strong></p><p>拷贝对象和原始对象的引用类型引用不同对象。</p></li><li><p><strong>clone() 的替代方案</strong></p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/07/17/hello-world/"/>
      <url>/2020/07/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
